#include <bits/time.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <string.h>
#include <linux/input.h>
#include <fcntl.h>

#include "easydisplib.h"

#define FPS_RENDER 15
#define FRAME_TIME_RENDER 1.0 / FPS_RENDER

#define FPS_LOOP 30

#define RES_X fb.vinfo.xres
#define RES_Y fb.vinfo.yres
#define BLACK 0xFF000000
#define WHITE 0xFFFFFFFF
#define GRASS 0xFF004400

#define BALL_SIZE RES_X / 100
#define PADDLE_WIDTH RES_X / 100
#define PADDLE_HEIGHT RES_Y / 10
#define PADDLE_OFFSET RES_X  / 70

#define EXIT_GAME_FAILURE exit_game(&screen, &field, &ball, &paddle_1, &paddle_2, &fb, kbd_fd, EXIT_FAILURE)
#define EXIT_GAME_SUCCESS exit_game(&screen, &field, &ball, &paddle_1, &paddle_2, &fb, kbd_fd, EXIT_SUCCESS)

#define MINVAL(a, b) ((a) < (b) ? (a):(b))
#define MAXVAL(a, b) ((a) > (b) ? (a):(b))

// Procedure to find the keyboard. Needed to read the user input.
// Generated by IA: Google GEMINI.
void find_keyboard_device(char *path) {
    FILE *fp = fopen("/proc/bus/input/devices", "r");
    if (!fp) return;

    char line[256];
    char current_event[16] = "";
    int is_keyboard = 0;

    while (fgets(line, sizeof(line), fp)) {
        // Find the event handlers
        if (strstr(line, "Handlers=") && strstr(line, "event")) {
            char *ev = strstr(line, "event");
            sscanf(ev, "event%s", current_event);
        }

        // Searching for the keyboard firm (EV=120013 o 12001f)
        if (strstr(line, "EV=120013") || strstr(line, "EV=12001f")) {
            is_keyboard = 1;
        }

        // Save the path if it is a keyboard
        if (line[0] == '\n' || feof(fp)) {
            if (is_keyboard && current_event[0] != '\0') {
                sprintf(path, "/dev/input/event%s", current_event);
                break;
            }
            is_keyboard = 0;
        }
    }
    fclose(fp);
}


// Procedure to safely exit the game.
int exit_game(EDL_SCREEN *screen,
              EDL_SPRITE *field,
              EDL_SPRITE *ball,
              EDL_SPRITE *paddle_1,
              EDL_SPRITE *paddle_2,
              EDL_FB * fb,
              int kbd_fd,
              const int return_value) {

    // Free memory
    edl_dalloc_screen(screen);
    edl_dalloc_sprite(field);
    edl_dalloc_sprite(ball);
    edl_dalloc_sprite(paddle_1);
    edl_dalloc_sprite(paddle_2);

    // Close framebuffer
    edl_close_fb(fb);

    // Release the keyboard
    ioctl(kbd_fd, EVIOCGRAB, 0);
    close(kbd_fd);
    return return_value;
}

int main() {

    // Screen
    EDL_SCREEN screen;

    // Sprites
    EDL_SPRITE field;
    EDL_SPRITE ball;
    EDL_SPRITE paddle_1;
    EDL_SPRITE paddle_2;

    // Framebuffer
    EDL_FB fb;

    // Errors
    edl_u32 err;

    // Find keyboard device
    char keyboard_path[256];
    find_keyboard_device(keyboard_path);
    
    // Open keyboard device
    struct input_event ev;
    int kbd_fd;    
    kbd_fd = open(keyboard_path, O_RDONLY | O_NONBLOCK);
    if (kbd_fd == -1) return EXIT_GAME_FAILURE;
    
    // Grab the keyboard (1 = grab, 0 = release). This way writting on terminal is avoided
    if (ioctl(kbd_fd, EVIOCGRAB, 1) == 1) {
        return EXIT_FAILURE;
    }

    // Framebuffer
    err = edl_open_fb(&fb);
    if (err) EXIT_GAME_FAILURE;

    // Initialize screen
    err = edl_init_screen(&screen, RES_X, RES_Y, BLACK);
    if (err) return EXIT_GAME_FAILURE;

    // initialize sprites
    err = edl_init_sprite(&field);
    if (err) return EXIT_GAME_FAILURE;

    err = edl_init_sprite(&ball);
    if (err) return EXIT_GAME_FAILURE;

    err = edl_init_sprite(&paddle_1);
    if (err) return EXIT_GAME_FAILURE;

    err = edl_init_sprite(&paddle_2);
    if (err) return EXIT_GAME_FAILURE;

    // Create sprites
    // FIELD
    err = edl_square_sprite(&field , RES_X, RES_Y, GRASS);
    if (err) return EXIT_GAME_FAILURE;

    // BALL
    err = edl_circle_sprite(&ball, BALL_SIZE, WHITE);
    if (err) return EXIT_GAME_FAILURE;

    // PADDLE 1
    err = edl_square_sprite(&paddle_1, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE);
    if (err) return EXIT_GAME_FAILURE;

    // PADDLE 2
    err = edl_square_sprite(&paddle_2, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE);
    if (err) return EXIT_GAME_FAILURE;

    // Define objects initial positions
    // Center of the screen
    EDL_VEC2 center = {RES_X / 2, RES_Y / 2};
    EDL_VEC2 ball_pos = center;
    EDL_VEC2 paddle_1_pos = {PADDLE_OFFSET, center.y - (paddle_1.height / 2)};
    EDL_VEC2 paddle_2_pos = {RES_X - PADDLE_OFFSET - (paddle_2.width), center.y - (paddle_2.height / 2)};
    
    
    // Paddle speed
    edl_u32 paddle_speed = RES_Y / 5;

    // Game loop
    struct timespec start, end, start_loop, end_loop;
    double elapsed = 0, elapsed_loop = 0;
    int move_1 = 0;
    int move_2 = 0;
    int exit_game_loop = 0;
    int key_pressed[KEY_MAX + 1] = {0}; 
    while(exit_game_loop == 0) {
        // Get start time of a frame
        clock_gettime(CLOCK_MONOTONIC, &start);
        clock_gettime(CLOCK_MONOTONIC, &start_loop);

        // Clear screen
        err = edl_clear_screen(&screen, BLACK);
        if (err) return EXIT_GAME_FAILURE;

        // Get user input
        while(read(kbd_fd, &ev, sizeof(ev)) > 0) {
            if (ev.type != EV_KEY) continue;
            if (ev.value == 1) {
                if (ev.code == KEY_Q) key_pressed[KEY_Q] = 1;
                if (ev.code == KEY_S) key_pressed[KEY_S] = 1;
                if (ev.code == KEY_W) key_pressed[KEY_W] = 1;
                if (ev.code == KEY_UP) key_pressed[KEY_UP] = 1;
                if (ev.code == KEY_DOWN) key_pressed[KEY_DOWN] = 1;
            } else if(ev.value == 0) {
                if (ev.code == KEY_Q) key_pressed[KEY_Q] = 0;
                if (ev.code == KEY_S) key_pressed[KEY_S] = 0;
                if (ev.code == KEY_W) key_pressed[KEY_W] = 0;
                if (ev.code == KEY_UP) key_pressed[KEY_UP] = 0;
                if (ev.code == KEY_DOWN) key_pressed[KEY_DOWN] = 0;
            }
        }

        // Process user input
        move_1 = 0;
        move_2 = 0;
        if (key_pressed[KEY_Q]) exit_game_loop = 1;
        if (key_pressed[KEY_S]) move_1 += 1;
        if (key_pressed[KEY_W]) move_1 -= 1;
        if (key_pressed[KEY_DOWN]) move_2 += 1;
        if (key_pressed[KEY_UP]) move_2 -= 1;
        
        // Move
        edl_u32 move = paddle_speed / FPS_RENDER;
        if (move > paddle_1_pos.y && move_1 == -1) move = paddle_1_pos.y;
        if (move > RES_Y - (paddle_1_pos.y + PADDLE_HEIGHT) && move_1 == 1) move = RES_Y - (paddle_1_pos.y + PADDLE_HEIGHT);
        paddle_1_pos.y += move_1 * move;;
        move = paddle_speed / FPS_RENDER;
        if (move > paddle_2_pos.y && move_2 == -1) move = paddle_2_pos.y;
        if (move > RES_Y - (paddle_2_pos.y + PADDLE_HEIGHT) && move_2 == 1) move = RES_Y - (paddle_2_pos.y + PADDLE_HEIGHT);        
        paddle_2_pos.y += move_2 * move;

        
        // Draw everything
        err = edl_write_sprite_on_buffer(&screen, &field, 0, 0);
        if (err) return EXIT_GAME_FAILURE;

        err = edl_write_sprite_on_buffer(&screen, &ball, ball_pos.x, ball_pos.y);
        if (err) return EXIT_GAME_FAILURE;

        err = edl_write_sprite_on_buffer(&screen, &paddle_1, paddle_1_pos.x, paddle_1_pos.y);
        if (err) return EXIT_GAME_FAILURE;

        err = edl_write_sprite_on_buffer(&screen, &paddle_2, paddle_2_pos.x, paddle_2_pos.y);
        if (err) return EXIT_GAME_FAILURE;

        // Get end time of a frame
        clock_gettime(CLOCK_MONOTONIC, &end);
        clock_gettime(CLOCK_MONOTONIC, &end_loop);

        // Calculate elapsed time
        elapsed += (end.tv_sec - start.tv_sec) +
                   (end.tv_nsec - start.tv_nsec) / 1000000000.0;
        elapsed_loop += (end_loop.tv_sec - start_loop.tv_sec) * 1000000000.0 +
                   (end_loop.tv_nsec - start_loop.tv_nsec);
        

        // Wait if necessary
        if (elapsed > FRAME_TIME_RENDER) {
            // show screen on framebuffer
            err = edl_show_screen_FB(&screen, &fb);
            if (err) return EXIT_GAME_FAILURE;
            elapsed = 0;
        }

        // Pause simulation to no overload the cpu
        struct timespec ts;
        ts.tv_nsec = 1.0 / FPS_LOOP;
        ts.tv_nsec -=elapsed_loop;
        if (ts.tv_nsec > 0) nanosleep(&ts, NULL);
    }

    return EXIT_GAME_SUCCESS;
}
