#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <string.h>
#include <linux/input.h>
#include <fcntl.h>

#include "easydisplib.h"

#define FPS 30
#define FRAME_TIME 1.0 / FPS

#define KEY_Q 16
#define KEY_A 30
#define KEY_S 31
#define KEY_D 32
#define KEY_W 17
#define ARROW_LEFT 105
#define ARROW_DOWN 108
#define ARROW_RIGHT 106
#define ARROW_UP 103


#define RES_X fb.vinfo.xres
#define RES_Y fb.vinfo.yres
#define BLACK 0xFF000000
#define WHITE 0xFFFFFFFF
#define GRASS 0xFF004400

#define BALL_SIZE RES_X / 100
#define PADDLE_WIDTH RES_X / 100
#define PADDLE_HEIGHT RES_Y / 10
#define PADDLE_OFFSET RES_X  / 70

#define EXIT_GAME_FAILURE exit_game(&screen, &field, &ball, &paddle_1, &paddle_2, &fb, kbd_fd, EXIT_FAILURE)
#define EXIT_GAME_SUCCESS exit_game(&screen, &field, &ball, &paddle_1, &paddle_2, &fb, kbd_fd, EXIT_SUCCESS)

#define MINVAL(a, b) ((a) < (b) ? (a):(b))
#define MAXVAL(a, b) ((a) > (b) ? (a):(b))

// Procedure to find the keyboard. Needed to read the user input.
// Generated by IA: Google GEMINI.
void find_keyboard_device(char *path) {
    FILE *fp = fopen("/proc/bus/input/devices", "r");
    if (!fp) return;

    char line[256];
    char current_event[16] = "";
    int is_keyboard = 0;

    while (fgets(line, sizeof(line), fp)) {
        // Find the event handlers
        if (strstr(line, "Handlers=") && strstr(line, "event")) {
            char *ev = strstr(line, "event");
            sscanf(ev, "event%s", current_event);
        }

        // Searching for the keyboard firm (EV=120013 o 12001f)
        if (strstr(line, "EV=120013") || strstr(line, "EV=12001f")) {
            is_keyboard = 1;
        }

        // Save the path if it is a keyboard
        if (line[0] == '\n' || feof(fp)) {
            if (is_keyboard && current_event[0] != '\0') {
                sprintf(path, "/dev/input/event%s", current_event);
                break;
            }
            is_keyboard = 0;
        }
    }
    fclose(fp);
}


// Procedure to safely exit the game.
int exit_game(EDL_SCREEN *screen,
              EDL_SPRITE *field,
              EDL_SPRITE *ball,
              EDL_SPRITE *paddle_1,
              EDL_SPRITE *paddle_2,
              EDL_FB * fb,
              int kbd_fd,
              const int return_value) {

    // Free memory
    edl_dalloc_screen(screen);
    edl_dalloc_sprite(field);
    edl_dalloc_sprite(ball);
    edl_dalloc_sprite(paddle_1);
    edl_dalloc_sprite(paddle_2);

    // Close framebuffer
    edl_close_fb(fb);

    // Release the keyboard
    ioctl(kbd_fd, EVIOCGRAB, 0);
    close(kbd_fd);
    return return_value;
}

int main() {

    // Screen
    EDL_SCREEN screen;

    // Sprites
    EDL_SPRITE field;
    EDL_SPRITE ball;
    EDL_SPRITE paddle_1;
    EDL_SPRITE paddle_2;

    // Framebuffer
    EDL_FB fb;

    // Errors
    edl_u32 err;

    // Find keyboard device
    char keyboard_path[256];
    find_keyboard_device(keyboard_path);
    //printf("keyboard path: %s\n", keyboard_path);

    // Open keyboard device
    struct input_event ev;
    int kbd_fd;
    kbd_fd = open(keyboard_path, O_RDONLY | O_NONBLOCK);
    if (kbd_fd == -1) return EXIT_GAME_FAILURE;

    // Grab the keyboard (1 = grab, 0 = release). This way writting on terminal is avoided
    if (ioctl(kbd_fd, EVIOCGRAB, 1) == 1) {
        return EXIT_FAILURE;
    }

    // Framebuffer
    err = edl_open_fb(&fb);
    if (err) EXIT_GAME_FAILURE;

    // Initialize screen
    err = edl_init_screen(&screen, RES_X, RES_Y, BLACK);
    if (err) return EXIT_GAME_FAILURE;

    // initialize sprites
    err = edl_init_sprite(&field);
    if (err) return EXIT_GAME_FAILURE;

    err = edl_init_sprite(&ball);
    if (err) return EXIT_GAME_FAILURE;

    err = edl_init_sprite(&paddle_1);
    if (err) return EXIT_GAME_FAILURE;

    err = edl_init_sprite(&paddle_2);
    if (err) return EXIT_GAME_FAILURE;

    // Create sprites
    // FIELD
    err = edl_square_sprite(&field , RES_X, RES_Y, GRASS);
    if (err) return EXIT_GAME_FAILURE;

    // BALL
    err = edl_circle_sprite(&ball, BALL_SIZE, WHITE);
    if (err) return EXIT_GAME_FAILURE;

    // PADDLE 1
    err = edl_square_sprite(&paddle_1, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE);
    if (err) return EXIT_GAME_FAILURE;

    // PADDLE 2
    err = edl_square_sprite(&paddle_2, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE);
    if (err) return EXIT_GAME_FAILURE;

    // Define objects initial positions
    // Center of the screen
    EDL_VEC2 center = {RES_X / 2, RES_Y / 2};
    EDL_VEC2 ball_pos = center;
    EDL_VEC2 paddle_1_pos = {PADDLE_OFFSET, center.y - (paddle_1.height / 2)};
    EDL_VEC2 paddle_2_pos = {RES_X - PADDLE_OFFSET - (paddle_2.width), center.y - (paddle_2.height / 2)};

    // Paddle speed
    edl_u32 paddle_speed = RES_Y / 5;

    // Game loop
    struct timespec start, end;
    double elapsed;
    int move_1 = 0;
    int move_2 = 0;
    int exit_game_loop = 0;
    while(exit_game_loop == 0) {
        // Get start time of a frame
        clock_gettime(CLOCK_MONOTONIC, &start);

        // Clear screen
        err = edl_clear_screen(&screen, BLACK);
        if (err) return EXIT_GAME_FAILURE;

        // Get user input
        int read_out = read(kbd_fd, &ev, sizeof(ev));

        if ( read_out > 0) {
            if (ev.type == EV_KEY && ev.value == 1) {
                // Quit
                if (ev.code == KEY_Q) {
                    exit_game_loop = 1;
                }

                // paddle_1 input
                // Move up
                if (ev.code == KEY_W) {
                    move_1 -= 1;
                    if (move_1 < -1) move_1 = -1;
                }
                // Move down
                if (ev.code == KEY_S) {
                    move_1 += 1;
                    if (move_1 > 1) move_1 = 1;
                }

                // paddle_2 Input
                // Move up
                if (ev.code == ARROW_UP) {
                    move_2 -= 1;
                    if (move_2 < -1) move_2 = -1;
                }
                // Move down
                if (ev.code == ARROW_DOWN) {
                    move_2 += 1;
                    if (move_2 > 1) move_2 = 1;
                }
            }

        }

        // Move
        paddle_1_pos.y += move_1 * (paddle_speed / FPS);
        paddle_2_pos.y += move_2 * (paddle_speed / FPS);

        // Draw everything
        err = edl_write_sprite_on_buffer(&screen, &field, 0, 0);
        if (err) return EXIT_GAME_FAILURE;

        err = edl_write_sprite_on_buffer(&screen, &ball, ball_pos.x, ball_pos.y);
        if (err) return EXIT_GAME_FAILURE;

        err = edl_write_sprite_on_buffer(&screen, &paddle_1, paddle_1_pos.x, paddle_1_pos.y);
        if (err) return EXIT_GAME_FAILURE;

        err = edl_write_sprite_on_buffer(&screen, &paddle_2, paddle_2_pos.x, paddle_2_pos.y);
        if (err) return EXIT_GAME_FAILURE;

        // show screen on framebuffer
        err = edl_show_screen_FB(&screen, &fb);
        if (err) return EXIT_GAME_FAILURE;

        // Get end time of a frame
        clock_gettime(CLOCK_MONOTONIC, &end);

        // Calculate elapsed time
        elapsed = (end.tv_sec - start.tv_sec) +
        (end.tv_nsec - start.tv_nsec) / 1000000000.0;

        // Wait if necessary
        if (elapsed < FRAME_TIME) {
            struct timespec sleep_time;
            double wait = FRAME_TIME - elapsed;

            sleep_time.tv_sec = 0;
            sleep_time.tv_nsec = (long)(wait * 1000000000.0);
            nanosleep(&sleep_time, NULL);
        }
    }

    return EXIT_GAME_SUCCESS;
}
